---
layout: post
title: "期末数据结构复习（一）"
date: 2017-12-18 19:07:00 +0300
categories:
- Data_Struct
tags:
- Data_Struct
---

# Link Start
## 第一天从线性表开始
**线性表**是一种最常用得数据结构，是一个n个元素构成的序列，它通过位置来确定相互的关系,相邻元素之间存在着序偶关系。若将线性表记为：
>   (a1,a2,a3 .......,ai-1,ai,ai+1,......an) 

则称ai-1是ai的直接前驱，ai+1是ai的直接后继，当 i = 1,2,3,...,n-1时，ai有且只有一个直接后继，当i= 2,3,4,.....n时,ai有且只有一个直接前驱。

## 线性表的实现
* 1 顺序表示和实现
顺序实现时指用一组地址连续的单元依次存放线性表的元素，线性表中第i+1个数据元素的存储位置LOC(ai+1)和第i个数据元素的存储位置LOC(ai)之间满足关系:
>   LOC(ai+1)=LOC(ai)+l
一般来说，线性表第i个元素ai的存储位置为：
    LOC(ai) = LOC(a1)+(i-1)Xl

顺序线性表的简单实现时利用数组完成的
对于声明可以有两种方法，一种是

``` ElemType elem[List_Size]```
因为C语言数组下标从0开始计数，可以把elem[0]用来储存顺序表的长度，将第i个元素储存在elem[i]内。
第二种方法时利用结构体
```
#define LIST_INT_SIZE 100 //线性表存储空间初始分配量
#definde LISTINCREMENT 10 //每次增加的分配量
typedef struct {
    ElemType *elem;
    int length;
    int listsize;//当前分配的空间大小
```
教科书所使用的就是第二种声明方法，是的元素的储存可以从数组的下标为0开始。length时当前线性表的长度。
我们需要做的第一件事是初始化一个线性表，为elem分配空间，
```
bool InitList(Sqlist &L)
{
	L.elem = (int *)malloc(sizeof(int)*LIST_INIT_SIZE);
	if (L.elem) 
	{
		L.length = 0;
		L.listsize = LIST_INIT_SIZE;
		return true;
	}
	else return false;
}
```
初始化之后，我们需要实现的三个有代表性的方法,第一个是在线性表中第i个位置插入一个元素e
插入前：
>   (a1,a2,a3...ai-1,ai,ai+1,...,an)

插入后：
>   (a1,a2,a3,...ai-1,e,ai,ai+1,...an)

当插入位置i合法时，将ai-1后的全部元素向后移动，然后将elem[i]变成e就完成了插入，代码实现如下：
```
//返回线性表的长度
int Len(Sqlist L)
{
	return L.length;
}
//将e插到线性表第i的位置上
bool ListInsert(Sqlist &L, int i, int e)
{
    //判断插入位置是否合法
	if (i<1 || i>Len(L) + 1)
		return false;
	//如果插入后长度超过现在的空间，重新申请
	if (L.length >= L.listsize)
	{
		int *newbase = (int *)realloc(L.elem, (L.listsize + LISTINCREMENT) * sizeof(int));
		if (!newbase)
			return false;
		L.elem = newbase;
		L.listsize += LISTINCREMENT;
	}
	int *q = &(L.elem[i - 1]);
	for (int *p = &(L.elem[L.length - 1]); p >= q; --p)
		*(p + 1) = *p;
	*q = e;
	++L.length;
	return true;
}
```
对于长度为n的顺序线性表，假设每个位置插入元素的概率时相等的，插入一个元素所需的平均移动次数是 n/2

对于删除一个表中的元素，将i后的元素逐个向前移动，然后表长减一,代码实现如下：
```
//删除表中的第I个元素
bool ListDelete(Sqlist &L, int i, int &e)
{
	if (i<1 || i>L.length)
		return false;//参数不合法
	int* p = &(L.elem[i - 1]);
	e = *p;
	int* q = L.elem + L.length - 1;
	for (++p; p <= q; ++p)
		*(p - 1) = *p;
	--L.length;
	return true;
}
```
假设删除每个位置的概率是相同的，删除元素的平均移动次数是
(n-1)/2

除了插入和删除，还需要实现两个线性表的合并。现在假设存在两个有序的线性表，La，Lb，将la,lb合并到lc。对于合并表而言，时间复杂度基本为O(La.length * Lb.length)。
假设La,Lb,是非递减的，合并后的Lc也是非递减的，于是在La,Lb未完结前，Lc[i] = min(La[a],Lb[i]),然后将未完的部分全部合并到Lc的尾部
代码实现如下：
```
//将两个线性表合并
void MergeList(Sqlist La, Sqlist Lb, Sqlist &Lc)
{
	Lc.length= La.length + Lb.length;
	Lc.listsize = LIST_INIT_SIZE;
	Lc.elem = (int *)malloc(sizeof(int)*Lc.listsize);
	int a = 0,b = 0;
	int i = 0;
	while (a < La.length&&b < Lb.length)
	{
		if (La.elem[a] > Lb.elem[b])
		{
			Lc.elem[i++] = Lb.elem[b++];
		}
		else
		{
			Lc.elem[i++] = La.elem[a++];
		}
	}
	while (a < La.length)
	{
		Lc.elem[i++] = La.elem[a++];
	}
	while (b<Lb.length)
	{
		Lc.elem[i++] = Lb.elem[b++];
	}
}
```